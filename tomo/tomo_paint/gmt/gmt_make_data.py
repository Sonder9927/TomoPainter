"""
1. get hull points and statistic info of grid files
2. plot [diff, vel, as, cb]
3. plot dispersion curves from vel_info
4. plot s-wave figs (need to collect data
   from all grids by `collect_grids`)
5. make ppt to show results
"""
from pathlib import Path

import pandas as pd
import pygmt


def makecpt(
    series, output="temp/temp.cpt", cpt="Vc_1.8s.cpt", reverse=False, cmap=None
):
    cpts = Path("data/txt/cptfiles")
    cmap = cmap or str(cpts / cpt)
    pygmt.makecpt(
        cmap=cmap,
        series=series,
        # truncate=[0.05, 0.85],
        output=output,
        continuous=True,
        background=True,
        reverse=reverse,
    )
    return output


def diff_make(ant, tpwt, region, cptfile, grds):
    pers_series = {
        "20": [3.45, 3.61, 0.01],
        "25": [3.63, 3.76, 0.01],
        "30": [3.7, 3.85, 0.01],
    }
    per = Path(ant).stem.split("_")[-1]
    series = pers_series.get(per)
    # make cpt file for tomo of vel of ant and tpwt
    # pygmt.makecpt(cmap=cmap, series=series, continuous=True, output=cptfile)
    makecpt(series, cptfile)

    # make vel grid of ant and get vel grid generated by `surface`
    ant = tomo_grid(ant, region, grds["ant"])
    tpwt = tomo_grid(tpwt, region, grds["tpwt"])

    # make diff grid
    merged = pd.merge(ant, tpwt, on=["x", "y"], how="left")
    merged["z"] = (merged["z_x"] - merged["z_y"]) * 1000
    diff = merged[["x", "y", "z"]]
    tomo_grid(diff, region, grds["diff"])
    return diff


def make_topos(
    idt,
    region,
    *,
    data="data/txt/tects/ETOPO1.grd",
    normalize="t",
    resolution=None,
    cmap="grayC",
    series=None,
):
    if series is None:
        series = [-100, 2000, 200]
    temp = Path("temp")
    ctopo = str(temp / f"topo_{cmap}.cpt")
    makecpt(series, ctopo, cmap=cmap)
    # pygmt.makecpt(
    #     cmap=cmap,
    #     series=series,
    #     continuous=True,
    #     output=ctopo,
    # )
    grd = temp / f"topo_{idt}.grd"
    gra = temp / f"topo_{idt}.gradient"
    topos = dict(
        zip(["grd", "gra", "cpt", "region"], [grd, gra, ctopo, region])
    )
    if Path(gra).exists():
        return topos
    TOPO_CUT = "temp/topo_cut.grd"
    TOPO_SAMPLE = "temp/topo_sample.grd"
    if resolution:
        data = pygmt.datasets.load_earth_relief(
            resolution=resolution, region=region, registration="gridline"
        )
    # grdcut
    pygmt.grdcut(
        grid=data,
        region=region,
        outgrid=TOPO_CUT,
    )
    # grdsample
    pygmt.grdsample(
        grid=TOPO_CUT,
        outgrid=TOPO_SAMPLE,
        region=region,
        spacing=0.01,
        # translate=True,
    )
    TOPO_GRA = "temp/topo.gradient"
    # grdgradient
    pygmt.grdgradient(
        grid=TOPO_SAMPLE,
        outgrid=TOPO_GRA,
        azimuth=45,
        normalize=normalize,
        verbose="w",
    )
    Path(TOPO_SAMPLE).rename(grd)
    Path(TOPO_GRA).rename(gra)
    return topos


###############################################################################


# def tomo_grid_data(data, outgrid, region, *, sf_grd=False, **spacings):
#     sf_grd = gmt_blockmean_surface_grdsample(
#         data, region, outgrid=outgrid, spacings=spacings
#     )
#     return sf_grd if sf_grd

# pre_sf = Path(sf_grd)
# if preffix:
#     pre_sf = pre_sf.parent / f"{preffix}_{pre_sf.name}"
#     Path(sf_grd).rename(pre_sf)

# return str(pre_sf)


def tomo_grid(data, region, outfile, **spacings):
    if spacings is None:
        spacings = {}
    # blockmean
    xyz = pygmt.blockmean(
        data=data,
        region=region,
        spacing=spacings.get("blockmean") or 0.5,
    )
    # surface
    grd = pygmt.surface(
        data=xyz,
        region=region,
        spacing=spacings.get("surface") or 0.5,
    )
    # grdsample
    pygmt.grdsample(
        grid=grd,
        spacing=spacings.get("grdsample") or 0.01,
        outgrid=outfile,
    )
    return pygmt.grd2xyz(grd)


def get_info(grd_file: str, ndigits: int = 1) -> list[float]:
    # pick up both min and max vel of grd_file
    grd = pd.read_csv(
        grd_file,
        usecols=[2],
        names=["vel"],
        index_col=None,
        header=None,
        delim_whitespace=True,
    )

    series = [min(grd.vel), max(grd.vel)]
    min_vel = int(pow(10, ndigits) * series[0] - 1) / pow(10, ndigits)
    max_vel = int(pow(10, ndigits) * series[1] + 2) / pow(10, ndigits)

    return [min_vel, max_vel]


# def sta_clip(region, *, grid=None, data=None, output=None):
#     hull = "data/txt/sta_hull.nc"
#     if grid is not None:
#         data = pygmt.grd2xyz(grid)
#     elif data is not None:
#         data = data
#     else:
#         raise KeyError("Input filename to `grid` or dataframe to `data`")
#     clip_data = pygmt.select(data, F=hull)
#     if output in ["grd", "grid"]:
#         return pygmt.xyz2grd(data=clip_data, region=region, spacing=0.01)
#     return clip_data


def area_clip(data, *, region=None, spacing=0.01):
    hull = Path("data/txt/area_hull.nc")
    if type(data) is str:
        data = pygmt.grd2xyz(data)
    clip_data = pygmt.select(data, F=hull)
    if clip_data is None:
        raise ValueError("Nothing were selected.")
    if region is not None:
        return pygmt.xyz2grd(data=clip_data, region=region, spacing=spacing)
    return clip_data


def series(grid, method=0):
    if type(grid) is not pd.DataFrame:
        grid = pd.read_csv(
            grid, delim_whitespace=True, names=["x", "y", "z"], header=None
        )
    grid: pd.DataFrame = area_clip(grid)  # pyright: ignore
    avg = grid["z"].mean()
    min_val = grid["z"].min()
    max_val = grid["z"].max()
    if method == 0:
        return [min_val, max_val, 0.01]
    elif method == 1:
        dev = min([avg - min_val, max_val - avg])
        return [avg - dev + 0.01, avg + dev - 0.01, 0.01]
    else:
        dev = max([avg - min_val, max_val - avg])
        return [avg - dev + 0.02, avg + dev - 0.02, 0.01]
